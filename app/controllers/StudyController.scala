package controllers

import play.api.mvc._

import javax.inject._

@Singleton
class StudyController @Inject()(val controllerComponents: ControllerComponents) extends BaseController {

  def study = Action { _ =>
    // 5. 関数
    // 5-2. 関数のある世界

    // 関数。なんといい響きなんでしょうか(謎)。
    // 関数はすごく雑に言い表しますと、
    // "処理の塊に名前をつけて、再利用できるようにしたもの。"
    // です。

    // 前回の"前に移動"・"右に移動"する処理を、
    // 関数にしてみると以下のような形になります。

    def moveToFront(): Unit = {
      var state = ""
      state = "右足を上げる。"
      state = "右足を前に出す。"
      state = "右足を下げる。"
      state = "左足を上げる。"
      state = "左足を前に出す。"
      state = "左足を下げる。"
    }

    def moveToRight(): Unit = {
      var state = ""
      state = "右足を上げる。"
      state = "右足を右に出す。"
      state = "右足を下げる。"
      state = "左足を上げる。"
      state = "左足を右に出す。"
      state = "左足を下げる。"
    }
    
    // 関数を定義する方法の1つが上述例の通り、
    // 以下の書き方になります。
    // def 関数名(引数): 関数が返す型 = { 処理 }
    
    // `引数`は次回解説しますので一旦お忘れを。
    
    // 処理部分が`{}`で囲まれていますが、
    // これは2-10でやったブロックと同じです。
    // 1行だけなら`{}`は省略可能で、
    // 最終行がそのブロックの値になるというのも同じです。
    
    // 今回、初登場のUnitという型名が"関数の返す型"として指定されていますが、
    // このUnitというのは特殊な型で、
    // "値が無い"ことを表す型になっています。
    // 今回、どちらの関数も最終行は変数に値を入れる処理になっていますが、
    // 代入演算子`=`は変数に値を入れて、それで終わりで、
    // 式の結果としてはUnitということになっていますので、
    // 関数の結果としてもUnitとなる形です。
    
    // 説明が長くなっていますが、
    // もう1つ大事なポイントとしまして、
    // 関数は定義しても、呼び出さなければ何も動かないという特徴があります。
    // 呼び出す際には、関数名を改めて書く形になります。
    // 前回同様に、"前・右・前と進む処理"をやりたい場合は以下となります。
    moveToFront()
    moveToRight()
    moveToFront()
    
    // 処理の塊に対して、意味のある名前がついたので、
    // 何をしているのかが、非常にわかりやすくなったのではないでしょうか？
    
    // さらに、修正が必要になった時も、
    // 例えば"前に進む"処理は、"moveToFront"関数の中に一度だけ書かれているだけなので、
    // 一箇所修正すればそれで済むことになります。
    
    // YES.これがヘブンです。

    Ok("関数最高！！").as(HTML)
  }

}
